"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForLuaLibType = exports.transformBuiltinIdentifierExpression = exports.transformBuiltinCallExpression = exports.transformBuiltinPropertyAccessExpression = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const utils_1 = require("../../utils");
const lua_ast_1 = require("../utils/lua-ast");
const lualib_1 = require("../utils/lualib");
const symbols_1 = require("../utils/symbols");
const typescript_1 = require("../utils/typescript");
const array_1 = require("./array");
const console_1 = require("./console");
const function_1 = require("./function");
const global_1 = require("./global");
const math_1 = require("./math");
const number_1 = require("./number");
const object_1 = require("./object");
const promise_1 = require("./promise");
const string_1 = require("./string");
const symbol_1 = require("./symbol");
const diagnostics_1 = require("../utils/diagnostics");
function transformBuiltinPropertyAccessExpression(context, node) {
    const ownerType = context.checker.getTypeAtLocation(node.expression);
    if (ts.isIdentifier(node.expression) && (0, typescript_1.isStandardLibraryType)(context, ownerType, undefined)) {
        switch (node.expression.text) {
            case "Math":
                return (0, math_1.transformMathProperty)(context, node);
            case "Symbol":
                (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Symbol);
        }
    }
    if ((0, typescript_1.isStringType)(context, ownerType)) {
        return (0, string_1.transformStringProperty)(context, node);
    }
    if ((0, typescript_1.isArrayType)(context, ownerType)) {
        return (0, array_1.transformArrayProperty)(context, node);
    }
    if ((0, typescript_1.isFunctionType)(ownerType)) {
        return (0, function_1.transformFunctionProperty)(context, node);
    }
}
exports.transformBuiltinPropertyAccessExpression = transformBuiltinPropertyAccessExpression;
function transformBuiltinCallExpression(context, node, isOptionalCall) {
    const unsupportedOptionalCall = () => {
        context.diagnostics.push((0, diagnostics_1.unsupportedBuiltinOptionalCall)(node));
        return lua.createNilLiteral();
    };
    const expressionType = context.checker.getTypeAtLocation(node.expression);
    if (ts.isIdentifier(node.expression) && (0, typescript_1.isStandardLibraryType)(context, expressionType, undefined)) {
        checkForLuaLibType(context, expressionType);
        const result = (0, global_1.transformGlobalCall)(context, node);
        if (result) {
            if (isOptionalCall)
                return unsupportedOptionalCall();
            return result;
        }
    }
    const expression = ts.getOriginalNode(node.expression);
    if (!ts.isPropertyAccessExpression(expression)) {
        return;
    }
    const isOptionalAccess = expression.questionDotToken;
    (0, utils_1.assume)(node);
    // If the function being called is of type owner.func, get the type of owner
    const ownerType = context.checker.getTypeAtLocation(expression.expression);
    if ((0, typescript_1.isStandardLibraryType)(context, ownerType, undefined)) {
        const symbol = ownerType.getSymbol();
        switch (symbol === null || symbol === void 0 ? void 0 : symbol.name) {
            case "ArrayConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, array_1.transformArrayConstructorCall)(context, node);
            case "Console":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, console_1.transformConsoleCall)(context, node);
            case "Math":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, math_1.transformMathCall)(context, node);
            case "StringConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, string_1.transformStringConstructorCall)(context, node);
            case "ObjectConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, object_1.transformObjectConstructorCall)(context, node);
            case "SymbolConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, symbol_1.transformSymbolConstructorCall)(context, node);
            case "NumberConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, number_1.transformNumberConstructorCall)(context, node);
            case "PromiseConstructor":
                if (isOptionalCall || isOptionalAccess)
                    return unsupportedOptionalCall();
                return (0, promise_1.transformPromiseConstructorCall)(context, node);
        }
    }
    const isStringFunction = (0, typescript_1.isStringType)(context, ownerType) ||
        (expression.questionDotToken && (0, typescript_1.isNullableType)(context, ownerType, typescript_1.isStringType));
    if (isStringFunction && (0, typescript_1.hasStandardLibrarySignature)(context, node)) {
        if (isOptionalCall)
            return unsupportedOptionalCall();
        return (0, string_1.transformStringPrototypeCall)(context, node);
    }
    const isNumberFunction = (0, typescript_1.isNumberType)(context, ownerType) ||
        (expression.questionDotToken && (0, typescript_1.isNullableType)(context, ownerType, typescript_1.isNumberType));
    if (isNumberFunction && (0, typescript_1.hasStandardLibrarySignature)(context, node)) {
        if (isOptionalCall)
            return unsupportedOptionalCall();
        return (0, number_1.transformNumberPrototypeCall)(context, node);
    }
    const isArrayFunction = (0, typescript_1.isArrayType)(context, ownerType) ||
        (expression.questionDotToken && (0, typescript_1.isNullableType)(context, ownerType, typescript_1.isArrayType));
    if (isArrayFunction && (0, typescript_1.hasStandardLibrarySignature)(context, node)) {
        if (isOptionalCall)
            return unsupportedOptionalCall();
        return (0, array_1.transformArrayPrototypeCall)(context, node);
    }
    const isFunctionFunction = (0, typescript_1.isFunctionType)(ownerType) ||
        (expression.questionDotToken && (0, typescript_1.isNullableType)(context, ownerType, (_, t) => (0, typescript_1.isFunctionType)(t)));
    if (isFunctionFunction && (0, typescript_1.hasStandardLibrarySignature)(context, node)) {
        if (isOptionalCall)
            return unsupportedOptionalCall();
        return (0, function_1.transformFunctionPrototypeCall)(context, node);
    }
    const objectResult = (0, object_1.transformObjectPrototypeCall)(context, node, expression);
    if (objectResult) {
        if (isOptionalCall)
            return unsupportedOptionalCall();
        return objectResult;
    }
}
exports.transformBuiltinCallExpression = transformBuiltinCallExpression;
function transformBuiltinIdentifierExpression(context, node) {
    switch (node.text) {
        case "NaN":
            return (0, lua_ast_1.createNaN)(node);
        case "Infinity":
            const math = lua.createIdentifier("math");
            const huge = lua.createStringLiteral("huge");
            return lua.createTableIndexExpression(math, huge, node);
        case "globalThis":
            return lua.createIdentifier("_G", node, (0, symbols_1.getIdentifierSymbolId)(context, node), "globalThis");
    }
}
exports.transformBuiltinIdentifierExpression = transformBuiltinIdentifierExpression;
const builtinErrorTypeNames = new Set([
    "Error",
    "ErrorConstructor",
    "RangeError",
    "RangeErrorConstructor",
    "ReferenceError",
    "ReferenceErrorConstructor",
    "SyntaxError",
    "SyntaxErrorConstructor",
    "TypeError",
    "TypeErrorConstructor",
    "URIError",
    "URIErrorConstructor",
]);
function checkForLuaLibType(context, type) {
    if (!type.symbol)
        return;
    const name = context.checker.getFullyQualifiedName(type.symbol);
    switch (name) {
        case "Map":
        case "MapConstructor":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Map);
            return;
        case "Set":
        case "SetConstructor":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Set);
            return;
        case "WeakMap":
        case "WeakMapConstructor":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.WeakMap);
            return;
        case "WeakSet":
        case "WeakSetConstructor":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.WeakSet);
            return;
    }
    if (builtinErrorTypeNames.has(name)) {
        (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Error);
    }
}
exports.checkForLuaLibType = checkForLuaLibType;
//# sourceMappingURL=index.js.map